directive @config(esType: String, index: Boolean, link: LinkConfig, preset: String, searchable: Boolean, source: String) on ENUM_VALUE | FIELD_DEFINITION

"""Repeat fragment fields as children selection by `depth`"""
directive @recursive(
  """Recursion level (default: `1`, max: `10`)"""
  depth: Int = 1
) on FIELD | INLINE_FRAGMENT

type ArticleListComponent implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  articleListCount: Int
}

type ArticleListComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type ArticleListComponentFacet {
  _metadata: IContentMetadataFacet
}

input ArticleListComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ArticleListComponentOutput {
  autocomplete: ArticleListComponentAutocomplete
  cursor: String
  facets: ArticleListComponentFacet
  item: ArticleListComponent
  items: [ArticleListComponent]
  total(all: Boolean): Int
}

input ArticleListComponentWhereInput {
  _and: [ArticleListComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ArticleListComponentWhereInput]
  _or: [ArticleListComponentWhereInput]
}

type BlankExperience implements IData & _IContent & _IExperience & _IPage {
  BlankExperienceSeoSettings: PageSeoSettingsProperty
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

type BlankExperienceAutocomplete {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyAutocomplete
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type BlankExperienceFacet {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyFacet
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input BlankExperienceOrderByInput {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type BlankExperienceOutput {
  autocomplete: BlankExperienceAutocomplete
  cursor: String
  facets: BlankExperienceFacet
  item: BlankExperience
  items: [BlankExperience]
  total(all: Boolean): Int
}

input BlankExperienceWhereInput {
  BlankExperienceSeoSettings: PageSeoSettingsPropertyWhereInput
  _and: [BlankExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlankExperienceWhereInput]
  _or: [BlankExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type BlankSection implements IData & _IComponent & _IContent & _ISection {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

type BlankSectionAutocomplete {
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type BlankSectionFacet {
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input BlankSectionOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type BlankSectionOutput {
  autocomplete: BlankSectionAutocomplete
  cursor: String
  facets: BlankSectionFacet
  item: BlankSection
  items: [BlankSection]
  total(all: Boolean): Int
}

input BlankSectionWhereInput {
  _and: [BlankSectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlankSectionWhereInput]
  _or: [BlankSectionWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type BlogListingBlock implements IData & _IComponent & _IContent {
  BlogListingItemCount: Int
  BlogListingShowFilters: Boolean
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type BlogListingBlockAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type BlogListingBlockFacet {
  _metadata: IContentMetadataFacet
}

input BlogListingBlockOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type BlogListingBlockOutput {
  autocomplete: BlogListingBlockAutocomplete
  cursor: String
  facets: BlogListingBlockFacet
  item: BlogListingBlock
  items: [BlogListingBlock]
  total(all: Boolean): Int
}

input BlogListingBlockWhereInput {
  _and: [BlogListingBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlogListingBlockWhereInput]
  _or: [BlogListingBlockWhereInput]
}

type BlogPostPage implements IData & _IContent & _IPage {
  ArticleAuthor(highlight: HighlightOptions): String
  ArticleSubHeading: String
  BlogPostBody: RichText
  BlogPostPromoImage: ContentReference
  Heading: String
  SeoSettings: PageSeoSettingsProperty
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type BlogPostPageAutocomplete {
  BlogPostBody: RichTextAutocomplete
  BlogPostPromoImage: ContentReferenceAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type BlogPostPageFacet {
  ArticleAuthor(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  BlogPostBody: RichTextFacet
  BlogPostPromoImage: ContentReferenceFacet
  SeoSettings: PageSeoSettingsPropertyFacet
  _metadata: IContentMetadataFacet
}

input BlogPostPageOrderByInput {
  ArticleAuthor: OrderBy
  BlogPostBody: RichTextOrderByInput
  BlogPostPromoImage: ContentReferenceOrderByInput
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type BlogPostPageOutput {
  autocomplete: BlogPostPageAutocomplete
  cursor: String
  facets: BlogPostPageFacet
  item: BlogPostPage
  items: [BlogPostPage]
  total(all: Boolean): Int
}

input BlogPostPageWhereInput {
  ArticleAuthor: SearchableStringFilterInput
  BlogPostBody: RichTextWhereInput
  BlogPostPromoImage: ContentReferenceWhereInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  _and: [BlogPostPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [BlogPostPageWhereInput]
  _or: [BlogPostPageWhereInput]
}

scalar Bool

type CTAComponent implements IData & _IComponent & _IContent {
  Link: ContentUrl
  Text: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type CTAComponentAutocomplete {
  Link: ContentUrlAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CTAComponentFacet {
  Link: ContentUrlFacet
  _metadata: IContentMetadataFacet
}

input CTAComponentOrderByInput {
  Link: ContentUrlOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CTAComponentOutput {
  autocomplete: CTAComponentAutocomplete
  cursor: String
  facets: CTAComponentFacet
  item: CTAComponent
  items: [CTAComponent]
  total(all: Boolean): Int
}

input CTAComponentWhereInput {
  Link: ContentUrlWhereInput
  _and: [CTAComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CTAComponentWhereInput]
  _or: [CTAComponentWhereInput]
}

type CardComponent implements IData & _IComponent & _IContent {
  CallToAction: Link
  CoverImage: ContentReference
  DisplayAs: String
  Heading: String
  OverlayText: String
  Subheading: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type CardComponentAutocomplete {
  CallToAction: LinkAutocomplete
  CoverImage: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CardComponentFacet {
  CallToAction: LinkFacet
  CoverImage: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input CardComponentOrderByInput {
  CallToAction: LinkOrderByInput
  CoverImage: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CardComponentOutput {
  autocomplete: CardComponentAutocomplete
  cursor: String
  facets: CardComponentFacet
  item: CardComponent
  items: [CardComponent]
  total(all: Boolean): Int
}

input CardComponentWhereInput {
  CallToAction: LinkWhereInput
  CoverImage: ContentReferenceWhereInput
  _and: [CardComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CardComponentWhereInput]
  _or: [CardComponentWhereInput]
}

type CarouselBlock implements IData & _IComponent & _IContent {
  CarouselItemsContentArea: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type CarouselBlockAutocomplete {
  CarouselItemsContentArea: _IContentAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type CarouselBlockFacet {
  CarouselItemsContentArea: _IContentFacet
  _metadata: IContentMetadataFacet
}

input CarouselBlockOrderByInput {
  CarouselItemsContentArea: _IContentOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type CarouselBlockOutput {
  autocomplete: CarouselBlockAutocomplete
  cursor: String
  facets: CarouselBlockFacet
  item: CarouselBlock
  items: [CarouselBlock]
  total(all: Boolean): Int
}

input CarouselBlockWhereInput {
  CarouselItemsContentArea: _IContentWhereInput
  _and: [CarouselBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [CarouselBlockWhereInput]
  _or: [CarouselBlockWhereInput]
}

type CompositionComponentNode implements ICompositionComponentNode & ICompositionNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  type: String
}

type CompositionDisplaySetting {
  key: String
  value: String
}

type CompositionDisplaySettingAutocomplete {
  key(limit: Int! = 10, value: String!): [String]
  value(limit: Int! = 10, value: String!): [String]
}

type CompositionDisplaySettingFacet {
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  value(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input CompositionDisplaySettingOrderByInput {
  key: OrderBy
  value: OrderBy
}

input CompositionDisplaySettingWhereInput {
  key: StringFilterInput
  value: StringFilterInput
}

type CompositionNode implements ICompositionNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  type: String
}

type CompositionStructureNode implements ICompositionNode & ICompositionStructureNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  nodes: [ICompositionNode]
  type: String
}

type CompositionStructureNodeAutocomplete {
  displayName(limit: Int! = 10, value: String!): [String]
  displaySettings: CompositionDisplaySettingAutocomplete
  displayTemplateKey(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  nodeType(limit: Int! = 10, value: String!): [String]
  nodes: ICompositionNodeAutocomplete
  type(limit: Int! = 10, value: String!): [String]
}

type CompositionStructureNodeFacet {
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  displaySettings: CompositionDisplaySettingFacet
  displayTemplateKey(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodes: ICompositionNodeFacet
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input CompositionStructureNodeOrderByInput {
  displayName: OrderBy
  displaySettings: CompositionDisplaySettingOrderByInput
  displayTemplateKey: OrderBy
  key: OrderBy
  nodeType: OrderBy
  nodes: ICompositionNodeOrderByInput
  type: OrderBy
}

input CompositionStructureNodeWhereInput {
  displayName: StringFilterInput
  displaySettings: CompositionDisplaySettingWhereInput
  displayTemplateKey: StringFilterInput
  key: StringFilterInput
  nodeType: StringFilterInput
  nodes: ICompositionNodeWhereInput
  type: StringFilterInput
}

type ContactComponent implements IData & _IComponent & _IContent {
  Contact: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type ContactComponentAutocomplete {
  Contact: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ContactComponentFacet {
  Contact: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input ContactComponentOrderByInput {
  Contact: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ContactComponentOutput {
  autocomplete: ContactComponentAutocomplete
  cursor: String
  facets: ContactComponentFacet
  item: ContactComponent
  items: [ContactComponent]
  total(all: Boolean): Int
}

input ContactComponentWhereInput {
  Contact: ContentReferenceWhereInput
  _and: [ContactComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ContactComponentWhereInput]
  _or: [ContactComponentWhereInput]
}

type ContactPage implements IData & _IContent & _IPage {
  Biography: RichText
  Designation: String
  Email: String
  Image: ContentReference
  Location: String
  Name: String
  Phone: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type ContactPageAutocomplete {
  Biography: RichTextAutocomplete
  Image: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type ContactPageFacet {
  Biography: RichTextFacet
  Image: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input ContactPageOrderByInput {
  Biography: RichTextOrderByInput
  Image: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ContactPageOutput {
  autocomplete: ContactPageAutocomplete
  cursor: String
  facets: ContactPageFacet
  item: ContactPage
  items: [ContactPage]
  total(all: Boolean): Int
}

input ContactPageWhereInput {
  Biography: RichTextWhereInput
  Image: ContentReferenceWhereInput
  _and: [ContactPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ContactPageWhereInput]
  _or: [ContactPageWhereInput]
}

type ContentMetadata implements IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

type ContentReference {
  key: String
  url: ContentUrl
}

type ContentReferenceAutocomplete {
  key(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
}

type ContentReferenceFacet {
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
}

input ContentReferenceOrderByInput {
  key: OrderBy
  url: ContentUrlOrderByInput
}

input ContentReferenceWhereInput {
  key: StringFilterInput
  url: ContentUrlWhereInput
}

type ContentUrl {
  base: String
  default: String
  graph: String
  hierarchical: String
  internal: String
  type: String
}

type ContentUrlAutocomplete {
  base(limit: Int! = 10, value: String!): [String]
  default(limit: Int! = 10, value: String!): [String]
  graph(limit: Int! = 10, value: String!): [String]
  hierarchical(limit: Int! = 10, value: String!): [String]
  internal(limit: Int! = 10, value: String!): [String]
  type(limit: Int! = 10, value: String!): [String]
}

type ContentUrlFacet {
  base(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  default(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  graph(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  hierarchical(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  internal(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input ContentUrlOrderByInput {
  base: OrderBy
  default: OrderBy
  graph: OrderBy
  hierarchical: OrderBy
  internal: OrderBy
  type: OrderBy
}

input ContentUrlWhereInput {
  base: StringFilterInput
  default: StringFilterInput
  graph: StringFilterInput
  hierarchical: StringFilterInput
  internal: StringFilterInput
  type: StringFilterInput
}

type Data implements IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
}

input DataOrderByInput {
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type DataOutput {
  cursor: String
  item: IData
  items: [IData]
  total(all: Boolean): Int
}

input DataWhereInput {
  _and: [DataWhereInput]
  _fulltext: SearchableStringFilterInput
  _modified: DateFilterInput
  _not: [DataWhereInput]
  _or: [DataWhereInput]
}

scalar Date

type DateFacet {
  count: Int
  name: String
}

enum DateFacetUnit {
  """
  Defined as 24 hours (86,400,000 milliseconds). All days begin at the earliest possible time, which is usually 00:00:00 (midnight).
  """
  DAY

  """
  Defined as 60 minutes each (3,600,000 milliseconds). All hours begin at 00 minutes and 00 seconds.
  """
  HOUR

  """Defined as 1000 milliseconds each."""
  MINUTE
}

input DateFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int

  """
  `decay` influences the weight of the score with a decay function. For example, results that have a more recent datetime will be ranked higher. The `origin` will be `now()` in case not specified. The `scale` is by default 10. The `rate` must be in the range `[0..1]`.
  """
  decay: Decay

  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: Date

  """`exist` matches results that have this field."""
  exist: Boolean

  """
  `gt` retrieves results with matches that have a value which is `greater than` it.
  """
  gt: Date

  """
  `gte` retrieves results with matches that have a value which is `greater than or equal to` it.
  """
  gte: Date

  """
  `lt` retrieves results with matches that have a value which is `lower than` it.
  """
  lt: Date

  """
  `lte` retrieves results with matches that have a value which is `lower than or equal to` it.
  """
  lte: Date

  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: Date
}

scalar DateTime

"""
Decay influences the weight of the score based on field values with a decay function
"""
input Decay {
  origin: Date
  rate: Float
  scale: Int = 10
}

type EventComponent implements IData & _IComponent & _IContent {
  Address: String
  Date: DateTime
  Title: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type EventComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type EventComponentFacet {
  _metadata: IContentMetadataFacet
}

input EventComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type EventComponentOutput {
  autocomplete: EventComponentAutocomplete
  cursor: String
  facets: EventComponentFacet
  item: EventComponent
  items: [EventComponent]
  total(all: Boolean): Int
}

input EventComponentWhereInput {
  _and: [EventComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [EventComponentWhereInput]
  _or: [EventComponentWhereInput]
}

type GenericMedia implements IData & _IContent & _IMedia {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type GenericMediaAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type GenericMediaFacet {
  _metadata: IContentMetadataFacet
}

input GenericMediaOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type GenericMediaOutput {
  autocomplete: GenericMediaAutocomplete
  cursor: String
  facets: GenericMediaFacet
  item: GenericMedia
  items: [GenericMedia]
  total(all: Boolean): Int
}

input GenericMediaWhereInput {
  _and: [GenericMediaWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [GenericMediaWhereInput]
  _or: [GenericMediaWhereInput]
}

type HeadingComponent implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  headingText: String
}

type HeadingComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type HeadingComponentFacet {
  _metadata: IContentMetadataFacet
}

input HeadingComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type HeadingComponentOutput {
  autocomplete: HeadingComponentAutocomplete
  cursor: String
  facets: HeadingComponentFacet
  item: HeadingComponent
  items: [HeadingComponent]
  total(all: Boolean): Int
}

input HeadingComponentWhereInput {
  _and: [HeadingComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [HeadingComponentWhereInput]
  _or: [HeadingComponentWhereInput]
}

type HeroComponent implements IData & _IComponent & _IContent {
  CallToAction: Link
  Heading: String
  Image: ContentReference
  RichText: RichText
  SubHeading: String
  Video: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type HeroComponentAutocomplete {
  CallToAction: LinkAutocomplete
  Image: ContentReferenceAutocomplete
  RichText: RichTextAutocomplete
  Video: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type HeroComponentFacet {
  CallToAction: LinkFacet
  Image: ContentReferenceFacet
  RichText: RichTextFacet
  Video: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input HeroComponentOrderByInput {
  CallToAction: LinkOrderByInput
  Image: ContentReferenceOrderByInput
  RichText: RichTextOrderByInput
  Video: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type HeroComponentOutput {
  autocomplete: HeroComponentAutocomplete
  cursor: String
  facets: HeroComponentFacet
  item: HeroComponent
  items: [HeroComponent]
  total(all: Boolean): Int
}

input HeroComponentWhereInput {
  CallToAction: LinkWhereInput
  Image: ContentReferenceWhereInput
  RichText: RichTextWhereInput
  Video: ContentReferenceWhereInput
  _and: [HeroComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [HeroComponentWhereInput]
  _or: [HeroComponentWhereInput]
}

"""Options for highlighting"""
input HighlightOptions {
  enabled: Boolean
  endToken: String
  startToken: String
}

interface ICompositionComponentNode implements ICompositionNode {
  component: _IComponent
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  type: String
}

interface ICompositionNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  type: String
}

type ICompositionNodeAutocomplete {
  displayName(limit: Int! = 10, value: String!): [String]
  displaySettings: CompositionDisplaySettingAutocomplete
  displayTemplateKey(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  nodeType(limit: Int! = 10, value: String!): [String]
  type(limit: Int! = 10, value: String!): [String]
}

type ICompositionNodeFacet {
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  displaySettings: CompositionDisplaySettingFacet
  displayTemplateKey(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  nodeType(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  type(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input ICompositionNodeOrderByInput {
  displayName: OrderBy
  displaySettings: CompositionDisplaySettingOrderByInput
  displayTemplateKey: OrderBy
  key: OrderBy
  nodeType: OrderBy
  type: OrderBy
}

input ICompositionNodeWhereInput {
  displayName: StringFilterInput
  displaySettings: CompositionDisplaySettingWhereInput
  displayTemplateKey: StringFilterInput
  key: StringFilterInput
  nodeType: StringFilterInput
  type: StringFilterInput
}

interface ICompositionStructureNode implements ICompositionNode {
  displayName: String
  displaySettings: [CompositionDisplaySetting]
  displayTemplateKey: String
  key: String
  nodeType: String
  nodes: [ICompositionNode]
  type: String
}

interface IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

type IContentMetadataAutocomplete {
  changeset(limit: Int! = 10, value: String!): [String]
  fallbackForLocale(limit: Int! = 10, value: String!): [String]
  key(limit: Int! = 10, value: String!): [String]
  locale(limit: Int! = 10, value: String!): [String]
  status(limit: Int! = 10, value: String!): [String]
  types(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
  version(limit: Int! = 10, value: String!): [String]
}

type IContentMetadataFacet {
  changeset(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  created(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  displayName(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  fallbackForLocale(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  key(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  lastModified(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  locale(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  published(unit: DateFacetUnit = DAY, value: Int = 1): [DateFacet]
  status(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  types(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
  version(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input IContentMetadataOrderByInput {
  changeset: OrderBy
  created: OrderBy
  displayName: OrderBy
  fallbackForLocale: OrderBy
  key: OrderBy
  lastModified: OrderBy
  locale: OrderBy
  published: OrderBy
  status: OrderBy
  types: OrderBy
  url: ContentUrlOrderByInput
  version: OrderBy
}

input IContentMetadataWhereInput {
  changeset: StringFilterInput
  created: DateFilterInput
  displayName: SearchableStringFilterInput
  fallbackForLocale: StringFilterInput
  key: StringFilterInput
  lastModified: DateFilterInput
  locale: StringFilterInput
  published: DateFilterInput
  status: StringFilterInput
  types: StringFilterInput
  url: ContentUrlWhereInput
  version: StringFilterInput
}

interface IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _modified: Date
  _score: Float
}

interface IInstanceMetadata implements IContentMetadata {
  changeset: String
  container: String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

interface IItemMetadata implements IContentMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  displayOption: String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

interface IMediaMetadata implements IContentMetadata & IInstanceMetadata {
  changeset: String
  container: String
  content(highlight: HighlightOptions): String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  mimeType: String
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  status: String
  thumbnail: String
  types: [String]
  url: ContentUrl
  version: String
}

type ImageComponent implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  altText: String
  imageLink: ContentReference
}

type ImageComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
  imageLink: ContentReferenceAutocomplete
}

type ImageComponentFacet {
  _metadata: IContentMetadataFacet
  imageLink: ContentReferenceFacet
}

input ImageComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  imageLink: ContentReferenceOrderByInput
}

type ImageComponentOutput {
  autocomplete: ImageComponentAutocomplete
  cursor: String
  facets: ImageComponentFacet
  item: ImageComponent
  items: [ImageComponent]
  total(all: Boolean): Int
}

input ImageComponentWhereInput {
  _and: [ImageComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ImageComponentWhereInput]
  _or: [ImageComponentWhereInput]
  imageLink: ContentReferenceWhereInput
}

type ImageMedia implements IData & _IContent & _IImage & _IMedia {
  AltText: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type ImageMediaAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type ImageMediaFacet {
  _metadata: IContentMetadataFacet
}

input ImageMediaOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type ImageMediaOutput {
  autocomplete: ImageMediaAutocomplete
  cursor: String
  facets: ImageMediaFacet
  item: ImageMedia
  items: [ImageMedia]
  total(all: Boolean): Int
}

input ImageMediaWhereInput {
  _and: [ImageMediaWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ImageMediaWhereInput]
  _or: [ImageMediaWhereInput]
}

type InstanceMetadata implements IContentMetadata & IInstanceMetadata {
  changeset: String
  container: String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

type ItemMetadata implements IContentMetadata & IItemMetadata {
  changeset: String
  created: DateTime
  displayName(highlight: HighlightOptions): String
  displayOption: String
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  locale: String
  published: DateTime
  status: String
  types: [String]
  url: ContentUrl
  version: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/publications-and-standards/standards/ecma-404/).
"""
scalar JSON

type LandingPage implements IData & _IContent & _IPage {
  MainContentArea: [_IContent]
  SeoSettings: PageSeoSettingsProperty
  TopContentArea: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type LandingPageAutocomplete {
  MainContentArea: _IContentAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  TopContentArea: _IContentAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type LandingPageFacet {
  MainContentArea: _IContentFacet
  SeoSettings: PageSeoSettingsPropertyFacet
  TopContentArea: _IContentFacet
  _metadata: IContentMetadataFacet
}

input LandingPageOrderByInput {
  MainContentArea: _IContentOrderByInput
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  TopContentArea: _IContentOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type LandingPageOutput {
  autocomplete: LandingPageAutocomplete
  cursor: String
  facets: LandingPageFacet
  item: LandingPage
  items: [LandingPage]
  total(all: Boolean): Int
}

input LandingPageWhereInput {
  MainContentArea: _IContentWhereInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  TopContentArea: _IContentWhereInput
  _and: [LandingPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [LandingPageWhereInput]
  _or: [LandingPageWhereInput]
}

type LayoutContainerBlock implements IData & _IComponent & _IContent {
  ColumnsCount: Int
  ContainerBackgroundColor: String
  ContainerBackgroundImage: ContentReference
  ContainerMarginBottom: String
  ContainerMarginTop: String
  ContainerPaddingBottom: String
  ContainerPaddingTop: String
  GapSize: String
  LayoutContentArea: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type LayoutContainerBlockAutocomplete {
  ContainerBackgroundImage: ContentReferenceAutocomplete
  LayoutContentArea: _IContentAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type LayoutContainerBlockFacet {
  ContainerBackgroundImage: ContentReferenceFacet
  LayoutContentArea: _IContentFacet
  _metadata: IContentMetadataFacet
}

input LayoutContainerBlockOrderByInput {
  ContainerBackgroundImage: ContentReferenceOrderByInput
  LayoutContentArea: _IContentOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type LayoutContainerBlockOutput {
  autocomplete: LayoutContainerBlockAutocomplete
  cursor: String
  facets: LayoutContainerBlockFacet
  item: LayoutContainerBlock
  items: [LayoutContainerBlock]
  total(all: Boolean): Int
}

input LayoutContainerBlockWhereInput {
  ContainerBackgroundImage: ContentReferenceWhereInput
  LayoutContentArea: _IContentWhereInput
  _and: [LayoutContainerBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [LayoutContainerBlockWhereInput]
  _or: [LayoutContainerBlockWhereInput]
}

type Link {
  target: String
  text(highlight: HighlightOptions): String
  title: String
  url: ContentUrl
}

type LinkAutocomplete {
  target(limit: Int! = 10, value: String!): [String]
  title(limit: Int! = 10, value: String!): [String]
  url: ContentUrlAutocomplete
}

input LinkConfig {
  from: String
  to: String
}

type LinkFacet {
  target(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  text(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  title(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
  url: ContentUrlFacet
}

input LinkOrderByInput {
  target: OrderBy
  text: OrderBy
  title: OrderBy
  url: ContentUrlOrderByInput
}

enum LinkTypes {
  "\n| *Direction* | &nbsp; | *Field*     |\n| ----------: | ------ | :---------- |\n| *from*      |        | `_metadata.key` |\n| *to*        |        | `_metadata.owner`   |"
  ASSETS

  "\n| *Direction* | &nbsp; | *Field*     |\n| ----------: | ------ | :---------- |\n| *from*      |        | `_metadata.key` |\n| *to*        |        | `_metadata.container`   |"
  DEFAULT

  "\n| *Direction* | &nbsp; | *Field*     |\n| ----------: | ------ | :---------- |\n| *from*      |        | `_metadata.key` |\n| *to*        |        | `_metadata.container`   |"
  ITEMS

  "\n| *Direction* | &nbsp; | *Field*     |\n| ----------: | ------ | :---------- |\n| *from*      |        | `_metadata.path` |\n| *to*        |        | `_metadata.key`   |"
  PATH
}

input LinkWhereInput {
  target: StringFilterInput
  text: SearchableStringFilterInput
  title: StringFilterInput
  url: ContentUrlWhereInput
}

enum Locales {
  ALL
  NEUTRAL
  en
}

type MediaMetadata implements IContentMetadata & IInstanceMetadata & IMediaMetadata {
  changeset: String
  container: String
  content(highlight: HighlightOptions): String
  created: DateTime
  createdBy: String
  displayName(highlight: HighlightOptions): String
  expired: DateTime
  fallbackForLocale: String
  key: String
  lastModified: DateTime
  lastModifiedBy: String
  locale: String
  locales: [String]
  mimeType: String
  owner: String
  path: [String]
  published: DateTime
  routeSegment: String
  status: String
  thumbnail: String
  types: [String]
  url: ContentUrl
  version: String
}

type MegaMenuGroupBlock implements IData & _IComponent & _IContent {
  MegaMenuContentArea: [_IContent]
  MegaMenuUrl: ContentUrl
  MenuMenuHeading: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type MegaMenuGroupBlockAutocomplete {
  MegaMenuContentArea: _IContentAutocomplete
  MegaMenuUrl: ContentUrlAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type MegaMenuGroupBlockFacet {
  MegaMenuContentArea: _IContentFacet
  MegaMenuUrl: ContentUrlFacet
  _metadata: IContentMetadataFacet
}

input MegaMenuGroupBlockOrderByInput {
  MegaMenuContentArea: _IContentOrderByInput
  MegaMenuUrl: ContentUrlOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type MegaMenuGroupBlockOutput {
  autocomplete: MegaMenuGroupBlockAutocomplete
  cursor: String
  facets: MegaMenuGroupBlockFacet
  item: MegaMenuGroupBlock
  items: [MegaMenuGroupBlock]
  total(all: Boolean): Int
}

input MegaMenuGroupBlockWhereInput {
  MegaMenuContentArea: _IContentWhereInput
  MegaMenuUrl: ContentUrlWhereInput
  _and: [MegaMenuGroupBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [MegaMenuGroupBlockWhereInput]
  _or: [MegaMenuGroupBlockWhereInput]
}

type MenuNavigationBlock implements IData & _IComponent & _IContent {
  MenuNavigationHeading: String
  NavigationLinks: [Link]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type MenuNavigationBlockAutocomplete {
  NavigationLinks: LinkAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type MenuNavigationBlockFacet {
  NavigationLinks: LinkFacet
  _metadata: IContentMetadataFacet
}

input MenuNavigationBlockOrderByInput {
  NavigationLinks: LinkOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type MenuNavigationBlockOutput {
  autocomplete: MenuNavigationBlockAutocomplete
  cursor: String
  facets: MenuNavigationBlockFacet
  item: MenuNavigationBlock
  items: [MenuNavigationBlock]
  total(all: Boolean): Int
}

input MenuNavigationBlockWhereInput {
  NavigationLinks: LinkWhereInput
  _and: [MenuNavigationBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [MenuNavigationBlockWhereInput]
  _or: [MenuNavigationBlockWhereInput]
}

enum OrderBy {
  ASC
  DESC
}

enum OrderByFacetType {
  COUNT
  VALUE
}

type PageSeoSettings implements IData & _IComponent & _IContent {
  GraphType: String
  MetaDescription: String
  MetaTitle: String
  SharingImage: ContentReference
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type PageSeoSettingsAutocomplete {
  SharingImage: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type PageSeoSettingsFacet {
  SharingImage: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input PageSeoSettingsOrderByInput {
  SharingImage: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type PageSeoSettingsOutput {
  autocomplete: PageSeoSettingsAutocomplete
  cursor: String
  facets: PageSeoSettingsFacet
  item: PageSeoSettings
  items: [PageSeoSettings]
  total(all: Boolean): Int
}

type PageSeoSettingsProperty {
  GraphType: String
  MetaDescription: String
  MetaTitle: String
  SharingImage: ContentReference
}

type PageSeoSettingsPropertyAutocomplete {
  SharingImage: ContentReferenceAutocomplete
}

type PageSeoSettingsPropertyFacet {
  SharingImage: ContentReferenceFacet
}

input PageSeoSettingsPropertyOrderByInput {
  SharingImage: ContentReferenceOrderByInput
}

input PageSeoSettingsPropertyWhereInput {
  SharingImage: ContentReferenceWhereInput
}

input PageSeoSettingsWhereInput {
  SharingImage: ContentReferenceWhereInput
  _and: [PageSeoSettingsWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [PageSeoSettingsWhereInput]
  _or: [PageSeoSettingsWhereInput]
}

type ParagraphComponent implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  text: RichText
}

type ParagraphComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
  text: RichTextAutocomplete
}

type ParagraphComponentFacet {
  _metadata: IContentMetadataFacet
  text: RichTextFacet
}

input ParagraphComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  text: RichTextOrderByInput
}

type ParagraphComponentOutput {
  autocomplete: ParagraphComponentAutocomplete
  cursor: String
  facets: ParagraphComponentFacet
  item: ParagraphComponent
  items: [ParagraphComponent]
  total(all: Boolean): Int
}

input ParagraphComponentWhereInput {
  _and: [ParagraphComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [ParagraphComponentWhereInput]
  _or: [ParagraphComponentWhereInput]
  text: RichTextWhereInput
}

type Query {
  ArticleListComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticleListComponentOrderByInput, skip: Int! = 0, where: ArticleListComponentWhereInput): ArticleListComponentOutput
  BlankExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankExperienceOrderByInput, skip: Int! = 0, where: BlankExperienceWhereInput): BlankExperienceOutput
  BlankSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankSectionOrderByInput, skip: Int! = 0, where: BlankSectionWhereInput): BlankSectionOutput
  BlogListingBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlogListingBlockOrderByInput, skip: Int! = 0, where: BlogListingBlockWhereInput): BlogListingBlockOutput
  BlogPostPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlogPostPageOrderByInput, skip: Int! = 0, where: BlogPostPageWhereInput): BlogPostPageOutput
  CTAComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CTAComponentOrderByInput, skip: Int! = 0, where: CTAComponentWhereInput): CTAComponentOutput
  CardComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CardComponentOrderByInput, skip: Int! = 0, where: CardComponentWhereInput): CardComponentOutput
  CarouselBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CarouselBlockOrderByInput, skip: Int! = 0, where: CarouselBlockWhereInput): CarouselBlockOutput
  ContactComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ContactComponentOrderByInput, skip: Int! = 0, where: ContactComponentWhereInput): ContactComponentOutput
  ContactPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ContactPageOrderByInput, skip: Int! = 0, where: ContactPageWhereInput): ContactPageOutput
  Data(cursor: String, ids: [String], limit: Int! = 20, locale: [system_Locales], orderBy: DataOrderByInput, skip: Int! = 0, where: DataWhereInput): DataOutput
  EventComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: EventComponentOrderByInput, skip: Int! = 0, where: EventComponentWhereInput): EventComponentOutput
  GenericMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GenericMediaOrderByInput, skip: Int! = 0, where: GenericMediaWhereInput): GenericMediaOutput
  HeadingComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeadingComponentOrderByInput, skip: Int! = 0, where: HeadingComponentWhereInput): HeadingComponentOutput
  HeroComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeroComponentOrderByInput, skip: Int! = 0, where: HeroComponentWhereInput): HeroComponentOutput
  ImageComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageComponentOrderByInput, skip: Int! = 0, where: ImageComponentWhereInput): ImageComponentOutput
  ImageMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageMediaOrderByInput, skip: Int! = 0, where: ImageMediaWhereInput): ImageMediaOutput
  LandingPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LandingPageOrderByInput, skip: Int! = 0, where: LandingPageWhereInput): LandingPageOutput
  LayoutContainerBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LayoutContainerBlockOrderByInput, skip: Int! = 0, where: LayoutContainerBlockWhereInput): LayoutContainerBlockOutput
  MegaMenuGroupBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MegaMenuGroupBlockOrderByInput, skip: Int! = 0, where: MegaMenuGroupBlockWhereInput): MegaMenuGroupBlockOutput
  MenuNavigationBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MenuNavigationBlockOrderByInput, skip: Int! = 0, where: MenuNavigationBlockWhereInput): MenuNavigationBlockOutput
  PageSeoSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageSeoSettingsOrderByInput, skip: Int! = 0, where: PageSeoSettingsWhereInput): PageSeoSettingsOutput
  ParagraphComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ParagraphComponentOrderByInput, skip: Int! = 0, where: ParagraphComponentWhereInput): ParagraphComponentOutput
  StandardPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: StandardPageOrderByInput, skip: Int! = 0, where: StandardPageWhereInput): StandardPageOutput
  StartPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: StartPageOrderByInput, skip: Int! = 0, where: StartPageWhereInput): StartPageOutput
  SysContentFolder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SysContentFolderOrderByInput, skip: Int! = 0, where: SysContentFolderWhereInput): SysContentFolderOutput
  TextBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TextBlockOrderByInput, skip: Int! = 0, where: TextBlockWhereInput): TextBlockOutput
  Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoOrderByInput, skip: Int! = 0, where: VideoWhereInput): VideoOutput
  VideoComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoComponentOrderByInput, skip: Int! = 0, where: VideoComponentWhereInput): VideoComponentOutput
  VideoMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoMediaOrderByInput, skip: Int! = 0, where: VideoMediaWhereInput): VideoMediaOutput
  _Component(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ComponentOrderByInput, skip: Int! = 0, where: _ComponentWhereInput): _ComponentOutput
  _Content(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ContentOrderByInput, skip: Int! = 0, where: _ContentWhereInput): _ContentOutput
  _Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ExperienceOrderByInput, skip: Int! = 0, where: _ExperienceWhereInput): _ExperienceOutput
  _Folder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _FolderOrderByInput, skip: Int! = 0, where: _FolderWhereInput): _FolderOutput
  _Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ImageOrderByInput, skip: Int! = 0, where: _ImageWhereInput): _ImageOutput
  _Media(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _MediaOrderByInput, skip: Int! = 0, where: _MediaWhereInput): _MediaOutput
  _Page(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _PageOrderByInput, skip: Int! = 0, where: _PageWhereInput): _PageOutput
  _Section(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _SectionOrderByInput, skip: Int! = 0, where: _SectionWhereInput): _SectionOutput
  _Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _VideoOrderByInput, skip: Int! = 0, where: _VideoWhereInput): _VideoOutput
}

""""""
type QueryRef {
  ArticleListComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ArticleListComponentOrderByInput, skip: Int! = 0, where: ArticleListComponentWhereInput): ArticleListComponentOutput
  BlankExperience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankExperienceOrderByInput, skip: Int! = 0, where: BlankExperienceWhereInput): BlankExperienceOutput
  BlankSection(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlankSectionOrderByInput, skip: Int! = 0, where: BlankSectionWhereInput): BlankSectionOutput
  BlogListingBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlogListingBlockOrderByInput, skip: Int! = 0, where: BlogListingBlockWhereInput): BlogListingBlockOutput
  BlogPostPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: BlogPostPageOrderByInput, skip: Int! = 0, where: BlogPostPageWhereInput): BlogPostPageOutput
  CTAComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CTAComponentOrderByInput, skip: Int! = 0, where: CTAComponentWhereInput): CTAComponentOutput
  CardComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CardComponentOrderByInput, skip: Int! = 0, where: CardComponentWhereInput): CardComponentOutput
  CarouselBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: CarouselBlockOrderByInput, skip: Int! = 0, where: CarouselBlockWhereInput): CarouselBlockOutput
  ContactComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ContactComponentOrderByInput, skip: Int! = 0, where: ContactComponentWhereInput): ContactComponentOutput
  ContactPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ContactPageOrderByInput, skip: Int! = 0, where: ContactPageWhereInput): ContactPageOutput
  Data(cursor: String, ids: [String], limit: Int! = 20, locale: [system_Locales], orderBy: DataOrderByInput, skip: Int! = 0, where: DataWhereInput): DataOutput
  EventComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: EventComponentOrderByInput, skip: Int! = 0, where: EventComponentWhereInput): EventComponentOutput
  GenericMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: GenericMediaOrderByInput, skip: Int! = 0, where: GenericMediaWhereInput): GenericMediaOutput
  HeadingComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeadingComponentOrderByInput, skip: Int! = 0, where: HeadingComponentWhereInput): HeadingComponentOutput
  HeroComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: HeroComponentOrderByInput, skip: Int! = 0, where: HeroComponentWhereInput): HeroComponentOutput
  ImageComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageComponentOrderByInput, skip: Int! = 0, where: ImageComponentWhereInput): ImageComponentOutput
  ImageMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ImageMediaOrderByInput, skip: Int! = 0, where: ImageMediaWhereInput): ImageMediaOutput
  LandingPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LandingPageOrderByInput, skip: Int! = 0, where: LandingPageWhereInput): LandingPageOutput
  LayoutContainerBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: LayoutContainerBlockOrderByInput, skip: Int! = 0, where: LayoutContainerBlockWhereInput): LayoutContainerBlockOutput
  MegaMenuGroupBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MegaMenuGroupBlockOrderByInput, skip: Int! = 0, where: MegaMenuGroupBlockWhereInput): MegaMenuGroupBlockOutput
  MenuNavigationBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: MenuNavigationBlockOrderByInput, skip: Int! = 0, where: MenuNavigationBlockWhereInput): MenuNavigationBlockOutput
  PageSeoSettings(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: PageSeoSettingsOrderByInput, skip: Int! = 0, where: PageSeoSettingsWhereInput): PageSeoSettingsOutput
  ParagraphComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: ParagraphComponentOrderByInput, skip: Int! = 0, where: ParagraphComponentWhereInput): ParagraphComponentOutput
  StandardPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: StandardPageOrderByInput, skip: Int! = 0, where: StandardPageWhereInput): StandardPageOutput
  StartPage(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: StartPageOrderByInput, skip: Int! = 0, where: StartPageWhereInput): StartPageOutput
  SysContentFolder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: SysContentFolderOrderByInput, skip: Int! = 0, where: SysContentFolderWhereInput): SysContentFolderOutput
  TextBlock(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: TextBlockOrderByInput, skip: Int! = 0, where: TextBlockWhereInput): TextBlockOutput
  Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoOrderByInput, skip: Int! = 0, where: VideoWhereInput): VideoOutput
  VideoComponent(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoComponentOrderByInput, skip: Int! = 0, where: VideoComponentWhereInput): VideoComponentOutput
  VideoMedia(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: VideoMediaOrderByInput, skip: Int! = 0, where: VideoMediaWhereInput): VideoMediaOutput
  _Component(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ComponentOrderByInput, skip: Int! = 0, where: _ComponentWhereInput): _ComponentOutput
  _Content(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ContentOrderByInput, skip: Int! = 0, where: _ContentWhereInput): _ContentOutput
  _Experience(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ExperienceOrderByInput, skip: Int! = 0, where: _ExperienceWhereInput): _ExperienceOutput
  _Folder(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _FolderOrderByInput, skip: Int! = 0, where: _FolderWhereInput): _FolderOutput
  _Image(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _ImageOrderByInput, skip: Int! = 0, where: _ImageWhereInput): _ImageOutput
  _Media(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _MediaOrderByInput, skip: Int! = 0, where: _MediaWhereInput): _MediaOutput
  _Page(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _PageOrderByInput, skip: Int! = 0, where: _PageWhereInput): _PageOutput
  _Section(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _SectionOrderByInput, skip: Int! = 0, where: _SectionWhereInput): _SectionOutput
  _Video(cursor: String, ids: [String], limit: Int! = 20, locale: [Locales], orderBy: _VideoOrderByInput, skip: Int! = 0, where: _VideoWhereInput): _VideoOutput
}

enum Ranking {
  BOOST_ONLY
  DOC
  RELEVANCE
  SEMANTIC
}

type RichText {
  html: String
  json: JSON
}

type RichTextAutocomplete {
  html(limit: Int! = 10, value: String!): [String]
}

type RichTextFacet {
  html(filters: [String!], limit: Int! = 10, orderBy: OrderBy = DESC, orderType: OrderByFacetType = COUNT): [StringFacet]
}

input RichTextOrderByInput {
  html: OrderBy
}

input RichTextWhereInput {
  html: StringFilterInput
}

input SearchableStringFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int

  """`contains` performs full-text search on a word or phrase."""
  contains: String

  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: String

  """`exist` matches results that have this field."""
  exist: Boolean

  """
  enables supporting fuzzy matching on the query terms (keywords), which returns items that contain terms in the content similar to the keywords, as measured by a _Levenshtein edit distance_. An edit distance is the number of one-character changes needed to turn one term into another. The edit distance is based on the length of the term. 
  """
  fuzzy: Boolean

  """
  `in` matches with 1 or more exact values in a list. Example: `in: ["word1", "word2", "this is a phrase"]`
  """
  in: [String]

  """
  `like` matches on substrings with wildcard support: `%` to match on 0 or more characters, `_` to match on any character. 
  """
  like: String

  """
  `match` performs full-text search on a word or phrase where less relevant items are also returned. The `match` operator is only supported for `searchable` fields. It will improve fulltext search by making it easier to match on words. More exact matches will be ranked higher, less exact matches will be ranked lower. The `match` operator is supported with synonyms and fuzzy search.
  """
  match: String

  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: String

  """
  `not_in` returns results that do not match with 1 or more exact values in a list. Example: `not_in: ["word1", "word2", "this is a phrase"]`
  """
  notIn: [String]

  """
  `starts_with` retrieves matches that start with a certain value (prefix).
  """
  startsWith: String

  """
  expands query value with synonyms. Example: if `H2O` is a synonym of `water`, then querying for `water` will also return results with `H2O`.
  """
  synonyms: [SynonymSlot]
}

type StandardPage implements IData & _IContent & _IPage {
  MainBody: RichText
  SeoSettings: PageSeoSettingsProperty
  StandardPageHeading: String
  StandardPromoImage: ContentReference
  StandardSubHeading: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type StandardPageAutocomplete {
  MainBody: RichTextAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  StandardPromoImage: ContentReferenceAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type StandardPageFacet {
  MainBody: RichTextFacet
  SeoSettings: PageSeoSettingsPropertyFacet
  StandardPromoImage: ContentReferenceFacet
  _metadata: IContentMetadataFacet
}

input StandardPageOrderByInput {
  MainBody: RichTextOrderByInput
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  StandardPromoImage: ContentReferenceOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type StandardPageOutput {
  autocomplete: StandardPageAutocomplete
  cursor: String
  facets: StandardPageFacet
  item: StandardPage
  items: [StandardPage]
  total(all: Boolean): Int
}

input StandardPageWhereInput {
  MainBody: RichTextWhereInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  StandardPromoImage: ContentReferenceWhereInput
  _and: [StandardPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [StandardPageWhereInput]
  _or: [StandardPageWhereInput]
}

type StartPage implements IData & _IContent & _IPage {
  FooterNavigationContentArea: [_IContent]
  FooterNavigationCopyrightText: String
  FooterNavigationSubLinks: [Link]
  HomePageHeroContentArea: [_IContent]
  HomePageMainContentArea: [_IContent]
  MainNavigationContentArea: [_IContent]
  SeoSettings: PageSeoSettingsProperty
  SiteImageLogo: ContentReference
  UtilityNavigationContentArea: [_IContent]
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type StartPageAutocomplete {
  FooterNavigationContentArea: _IContentAutocomplete
  FooterNavigationSubLinks: LinkAutocomplete
  HomePageHeroContentArea: _IContentAutocomplete
  HomePageMainContentArea: _IContentAutocomplete
  MainNavigationContentArea: _IContentAutocomplete
  SeoSettings: PageSeoSettingsPropertyAutocomplete
  SiteImageLogo: ContentReferenceAutocomplete
  UtilityNavigationContentArea: _IContentAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type StartPageFacet {
  FooterNavigationContentArea: _IContentFacet
  FooterNavigationSubLinks: LinkFacet
  HomePageHeroContentArea: _IContentFacet
  HomePageMainContentArea: _IContentFacet
  MainNavigationContentArea: _IContentFacet
  SeoSettings: PageSeoSettingsPropertyFacet
  SiteImageLogo: ContentReferenceFacet
  UtilityNavigationContentArea: _IContentFacet
  _metadata: IContentMetadataFacet
}

input StartPageOrderByInput {
  FooterNavigationContentArea: _IContentOrderByInput
  FooterNavigationSubLinks: LinkOrderByInput
  HomePageHeroContentArea: _IContentOrderByInput
  HomePageMainContentArea: _IContentOrderByInput
  MainNavigationContentArea: _IContentOrderByInput
  SeoSettings: PageSeoSettingsPropertyOrderByInput
  SiteImageLogo: ContentReferenceOrderByInput
  UtilityNavigationContentArea: _IContentOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type StartPageOutput {
  autocomplete: StartPageAutocomplete
  cursor: String
  facets: StartPageFacet
  item: StartPage
  items: [StartPage]
  total(all: Boolean): Int
}

input StartPageWhereInput {
  FooterNavigationContentArea: _IContentWhereInput
  FooterNavigationSubLinks: LinkWhereInput
  HomePageHeroContentArea: _IContentWhereInput
  HomePageMainContentArea: _IContentWhereInput
  MainNavigationContentArea: _IContentWhereInput
  SeoSettings: PageSeoSettingsPropertyWhereInput
  SiteImageLogo: ContentReferenceWhereInput
  UtilityNavigationContentArea: _IContentWhereInput
  _and: [StartPageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [StartPageWhereInput]
  _or: [StartPageWhereInput]
}

type StringFacet {
  count: Int
  name: String
}

input StringFilterInput {
  """
  `boost` influences the weight of a field by boosting a match with a number (default: 1) — counts more towards the eventual relevance score which can be projected with `_score` — at query time. Note that `boost` cannot be a negative number.
  """
  boost: Int

  """`ends_with` retrieves matches that end with a certain value (suffix)."""
  endsWith: String

  """`eq` matches on an exact value, but the value is case-insensitive."""
  eq: String

  """`exist` matches results that have this field."""
  exist: Boolean

  """
  enables supporting fuzzy matching on the query terms (keywords), which returns items that contain terms in the content similar to the keywords, as measured by a _Levenshtein edit distance_. An edit distance is the number of one-character changes needed to turn one term into another. The edit distance is based on the length of the term. 
  """
  fuzzy: Boolean

  """
  `in` matches with 1 or more exact values in a list. Example: `in: ["word1", "word2", "this is a phrase"]`
  """
  in: [String]

  """
  `like` matches on substrings with wildcard support: `%` to match on 0 or more characters, `_` to match on any character. 
  """
  like: String

  """
  `not_eq` retrieves results not matching with an exact (but case-insensitive) value.
  """
  notEq: String

  """
  `not_in` returns results that do not match with 1 or more exact values in a list. Example: `not_in: ["word1", "word2", "this is a phrase"]`
  """
  notIn: [String]

  """
  `starts_with` retrieves matches that start with a certain value (prefix).
  """
  startsWith: String

  """
  expands query value with synonyms. Example: if `H2O` is a synonym of `water`, then querying for `water` will also return results with `H2O`.
  """
  synonyms: [SynonymSlot]
}

enum SynonymSlot {
  """synonym slot 1"""
  ONE

  """synonym slot 2"""
  TWO
}

type SysContentFolder implements IData & _IContent & _IFolder {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type SysContentFolderAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type SysContentFolderFacet {
  _metadata: IContentMetadataFacet
}

input SysContentFolderOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type SysContentFolderOutput {
  autocomplete: SysContentFolderAutocomplete
  cursor: String
  facets: SysContentFolderFacet
  item: SysContentFolder
  items: [SysContentFolder]
  total(all: Boolean): Int
}

input SysContentFolderWhereInput {
  _and: [SysContentFolderWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [SysContentFolderWhereInput]
  _or: [SysContentFolderWhereInput]
}

type TextBlock implements IData & _IComponent & _IContent {
  TextBlockDescription: RichText
  TextBlockHeading: String
  TextBlockHeadingSize: String
  TextBlockOverline: String
  TextBlockWidth: String
  TextCenter: Boolean
  TextClassName: String
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type TextBlockAutocomplete {
  TextBlockDescription: RichTextAutocomplete
  _metadata: IContentMetadataAutocomplete
}

type TextBlockFacet {
  TextBlockDescription: RichTextFacet
  _metadata: IContentMetadataFacet
}

input TextBlockOrderByInput {
  TextBlockDescription: RichTextOrderByInput
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type TextBlockOutput {
  autocomplete: TextBlockAutocomplete
  cursor: String
  facets: TextBlockFacet
  item: TextBlock
  items: [TextBlock]
  total(all: Boolean): Int
}

input TextBlockWhereInput {
  TextBlockDescription: RichTextWhereInput
  _and: [TextBlockWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [TextBlockWhereInput]
  _or: [TextBlockWhereInput]
}

type Video implements IData & _IContent & _IMedia & _IVideo {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type VideoAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type VideoComponent implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  placeholder: ContentReference
  title: String
  video: ContentReference
}

type VideoComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
  placeholder: ContentReferenceAutocomplete
  video: ContentReferenceAutocomplete
}

type VideoComponentFacet {
  _metadata: IContentMetadataFacet
  placeholder: ContentReferenceFacet
  video: ContentReferenceFacet
}

input VideoComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  placeholder: ContentReferenceOrderByInput
  video: ContentReferenceOrderByInput
}

type VideoComponentOutput {
  autocomplete: VideoComponentAutocomplete
  cursor: String
  facets: VideoComponentFacet
  item: VideoComponent
  items: [VideoComponent]
  total(all: Boolean): Int
}

input VideoComponentWhereInput {
  _and: [VideoComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoComponentWhereInput]
  _or: [VideoComponentWhereInput]
  placeholder: ContentReferenceWhereInput
  video: ContentReferenceWhereInput
}

type VideoFacet {
  _metadata: IContentMetadataFacet
}

type VideoMedia implements IData & _IContent & _IMedia & _IVideo {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type VideoMediaAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type VideoMediaFacet {
  _metadata: IContentMetadataFacet
}

input VideoMediaOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type VideoMediaOutput {
  autocomplete: VideoMediaAutocomplete
  cursor: String
  facets: VideoMediaFacet
  item: VideoMedia
  items: [VideoMedia]
  total(all: Boolean): Int
}

input VideoMediaWhereInput {
  _and: [VideoMediaWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoMediaWhereInput]
  _or: [VideoMediaWhereInput]
}

input VideoOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type VideoOutput {
  autocomplete: VideoAutocomplete
  cursor: String
  facets: VideoFacet
  item: Video
  items: [Video]
  total(all: Boolean): Int
}

input VideoWhereInput {
  _and: [VideoWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [VideoWhereInput]
  _or: [VideoWhereInput]
}

type _Component implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _ComponentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _ComponentFacet {
  _metadata: IContentMetadataFacet
}

input _ComponentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ComponentOutput {
  autocomplete: _ComponentAutocomplete
  cursor: String
  facets: _ComponentFacet
  item: _IComponent
  items: [_IComponent]
  total(all: Boolean): Int
}

input _ComponentWhereInput {
  _and: [_ComponentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ComponentWhereInput]
  _or: [_ComponentWhereInput]
}

type _Content implements IData & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _ContentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _ContentFacet {
  _metadata: IContentMetadataFacet
}

input _ContentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ContentOutput {
  autocomplete: _ContentAutocomplete
  cursor: String
  facets: _ContentFacet
  item: _IContent
  items: [_IContent]
  total(all: Boolean): Int
}

input _ContentWhereInput {
  _and: [_ContentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ContentWhereInput]
  _or: [_ContentWhereInput]
}

type _Experience implements IData & _IContent & _IExperience & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

type _ExperienceAutocomplete {
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type _ExperienceFacet {
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input _ExperienceOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type _ExperienceOutput {
  autocomplete: _ExperienceAutocomplete
  cursor: String
  facets: _ExperienceFacet
  item: _IExperience
  items: [_IExperience]
  total(all: Boolean): Int
}

input _ExperienceWhereInput {
  _and: [_ExperienceWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ExperienceWhereInput]
  _or: [_ExperienceWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type _Folder implements IData & _IContent & _IFolder {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _FolderAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _FolderFacet {
  _metadata: IContentMetadataFacet
}

input _FolderOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _FolderOutput {
  autocomplete: _FolderAutocomplete
  cursor: String
  facets: _FolderFacet
  item: _IFolder
  items: [_IFolder]
  total(all: Boolean): Int
}

input _FolderWhereInput {
  _and: [_FolderWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_FolderWhereInput]
  _or: [_FolderWhereInput]
}

interface _IComponent implements IData & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

interface _IContent implements IData {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _IContentAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _IContentFacet {
  _metadata: IContentMetadataFacet
}

input _IContentOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

input _IContentWhereInput {
  _and: [_IContentWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_IContentWhereInput]
  _or: [_IContentWhereInput]
}

interface _IExperience implements IData & _IContent & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

interface _IFolder implements IData & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

interface _IImage implements IData & _IContent & _IMedia {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

interface _IMedia implements IData & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

interface _IPage implements IData & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

interface _ISection implements IData & _IComponent & _IContent {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

interface _IVideo implements IData & _IContent & _IMedia {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _Image implements IData & _IContent & _IImage & _IMedia {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _ImageAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _ImageFacet {
  _metadata: IContentMetadataFacet
}

input _ImageOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _ImageOutput {
  autocomplete: _ImageAutocomplete
  cursor: String
  facets: _ImageFacet
  item: _IImage
  items: [_IImage]
  total(all: Boolean): Int
}

input _ImageWhereInput {
  _and: [_ImageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_ImageWhereInput]
  _or: [_ImageWhereInput]
}

type _Media implements IData & _IContent & _IMedia {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _MediaAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _MediaFacet {
  _metadata: IContentMetadataFacet
}

input _MediaOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _MediaOutput {
  autocomplete: _MediaAutocomplete
  cursor: String
  facets: _MediaFacet
  item: _IMedia
  items: [_IMedia]
  total(all: Boolean): Int
}

input _MediaWhereInput {
  _and: [_MediaWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_MediaWhereInput]
  _or: [_MediaWhereInput]
}

type _Page implements IData & _IContent & _IPage {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _PageAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _PageFacet {
  _metadata: IContentMetadataFacet
}

input _PageOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _PageOutput {
  autocomplete: _PageAutocomplete
  cursor: String
  facets: _PageFacet
  item: _IPage
  items: [_IPage]
  total(all: Boolean): Int
}

input _PageWhereInput {
  _and: [_PageWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_PageWhereInput]
  _or: [_PageWhereInput]
}

type _Section implements IData & _IComponent & _IContent & _ISection {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
  composition: CompositionStructureNode
}

type _SectionAutocomplete {
  _metadata: IContentMetadataAutocomplete
  composition: CompositionStructureNodeAutocomplete
}

type _SectionFacet {
  _metadata: IContentMetadataFacet
  composition: CompositionStructureNodeFacet
}

input _SectionOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
  composition: CompositionStructureNodeOrderByInput
}

type _SectionOutput {
  autocomplete: _SectionAutocomplete
  cursor: String
  facets: _SectionFacet
  item: _ISection
  items: [_ISection]
  total(all: Boolean): Int
}

input _SectionWhereInput {
  _and: [_SectionWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_SectionWhereInput]
  _or: [_SectionWhereInput]
  composition: CompositionStructureNodeWhereInput
}

type _Video implements IData & _IContent & _IMedia & _IVideo {
  _children: QueryRef @deprecated(reason: "Use `_link` field instead")
  _deleted: Bool
  _fulltext(highlight: HighlightOptions): [String]
  _id: String
  _link(type: LinkTypes): QueryRef
  _metadata: IContentMetadata
  _modified: Date
  _score: Float
}

type _VideoAutocomplete {
  _metadata: IContentMetadataAutocomplete
}

type _VideoFacet {
  _metadata: IContentMetadataFacet
}

input _VideoOrderByInput {
  _metadata: IContentMetadataOrderByInput
  _minimumScore: Float
  _modified: OrderBy
  _ranking: Ranking

  """
  The value needs to be a positive value, but cannot exceed the maximum value of an integer. In case it is exceeded, the maximum of an integer is used. In case of a negative value, semantic search will be disabled.
  """
  _semanticWeight: Float
}

type _VideoOutput {
  autocomplete: _VideoAutocomplete
  cursor: String
  facets: _VideoFacet
  item: _IVideo
  items: [_IVideo]
  total(all: Boolean): Int
}

input _VideoWhereInput {
  _and: [_VideoWhereInput]
  _fulltext: SearchableStringFilterInput
  _metadata: IContentMetadataWhereInput
  _modified: DateFilterInput
  _not: [_VideoWhereInput]
  _or: [_VideoWhereInput]
}

enum system_Locales {
  ALL
  NEUTRAL
}